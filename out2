#! /usr/bin/env python3

import re

#
#
#
string_gringo_clasp_0 = ['clasp version 3.0.3\nReading from stdin\nUNSATISFIABLE\n\nModels       : 0     \nCalls        : 1\nTime         : 0.000s (Solving: 0.00s 1st Model: 0.00s Unsat: 0.00s)\nCPU Time     : 0.000s\n']

string_gringo_clasp_1= ['clasp version 3.0.3\nReading from stdin\nSolving...\nAnswer: 1\ndesign_type(detection_activity_exp) design_activity_det(growth)\nOptimization: 0\nOPTIMUM FOUND\n\nModels       : 1     \n  Optimum    : yes\nOptimization : 0\nCalls        : 1\nTime         : 0.020s (Solving: 0.00s 1st Model: 0.00s Unsat: 0.00s)\nCPU Time     : 0.010s\n']


def process_output(out):
	# check if program was satisfiable
	if 'UNSATISFIABLE' in out:
		return False
	# find optimum info:
	strings = out.split('\n')
	optimum = [st.split('Optimization : ')[1] for st in strings if st.startswith('Optimization : ')]
	if len(optimum) > 1:
		raise ValueError('process_output: more than one Optimisation info in the output')
	# find answers:
	answers = []
	counter = 0
	for st in strings:
		counter += 1
		if not st.startswith('Answer: '):
			continue
		optimization = strings[strings.index(counter) + 1].split('Optimization: ')[1] # get two after 'answer'
		if optimization == optimum:
			answers.append(strings[strings.index(counter)]) # get one after 'answer'
		else:
			pass
	# process answers:




#
#
#
#

#pat_answer = re.compile('Answer.*?\n\n\x1b', re.DOTALL)

#answers = pat_answer.findall(string)


#pat_add = re.compile('add\(.*?\)')
#pat_remove = re.compile('remove\(.*?\)')
#pat_not_incon = re.compile('not inconsistent\(.*?\)')

#output = {}
#counter = 0
#for ans in answers:
#	added = set(pat_add.findall(string))
#	removed = set(pat_remove.findall(string))
#	covered = set(pat_not_incon.findall(string))
#	counter += 1
#	output[counter] = (added, removed, covered)

#print(output)
